diff -uNr /home/proj2-base/defs.h ./defs.h
--- /home/proj2-base/defs.h	2021-05-08 14:28:44.452114548 +0800
+++ ./defs.h	2021-05-18 07:40:14.440694584 +0800
@@ -120,6 +120,12 @@
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+int 		    clone(void* (*)(void*), void *stack, void *arg);
+int 		    join(int, void **ret_p, void **stack);
+int             thread_exit(void *ret);
+void            sched_return(void);
+int             set_priority(int, int);
+int             enable_sched_display(int);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
diff -uNr /home/proj2-base/proc.c ./proc.c
--- /home/proj2-base/proc.c	2021-05-08 14:28:44.452114548 +0800
+++ ./proc.c	2021-05-18 09:32:45.696575644 +0800
@@ -15,6 +15,7 @@
 static struct proc *initproc;
 
 int nextpid = 1;
+int display_enabled = 0;
 extern void forkret(void);
 extern void trapret(void);
 
@@ -87,6 +88,9 @@
 
 found:
   p->state = EMBRYO;
+  
+  p->priority = 2;
+  
   p->pid = nextpid++;
 
   release(&ptable.lock);
@@ -255,7 +259,13 @@
   // Pass abandoned children to init.
   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
     if(p->parent == curproc){
-      p->parent = initproc;
+      kfree(p->kstack);
+      p->kstack = 0;
+      p->pid = 0;
+      p->parent = 0;
+      p->name[0] = 0;
+      p->killed = 0;
+      p->state = UNUSED;
       if(p->state == ZOMBIE)
         wakeup1(initproc);
     }
@@ -325,31 +335,41 @@
   struct proc *p;
   struct cpu *c = mycpu();
   c->proc = 0;
-  
+  int flag = 1;
   for(;;){
     // Enable interrupts on this processor.
     sti();
 
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
-        continue;
-
-      // Switch to chosen process.  It is the process's job
-      // to release ptable.lock and then reacquire it
-      // before jumping back to us.
-      c->proc = p;
-      switchuvm(p);
-      p->state = RUNNING;
-
-      swtch(&(c->scheduler), p->context);
-      switchkvm();
-
-      // Process is done running for now.
-      // It should have changed its p->state before coming back.
-      c->proc = 0;
+    for(int i = 1; i <= 3;){
+      flag = 1;
+      for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+        if(p->state != RUNNABLE || p->priority > i)
+          continue;
+        if(p->state == RUNNABLE && p->priority < i){
+          i = p->priority;
+          flag = 0;
+          break;
+        }
+
+        // Switch to chosen process.  It is the process's job
+        // to release ptable.lock and then reacquire it
+        // before jumping back to us.
+        c->proc = p;
+        switchuvm(p);
+        p->state = RUNNING;
+
+        swtch(&(c->scheduler), p->context);
+        switchkvm();
+
+        // Process is done running for now.
+        // It should have changed its p->state before coming back.
+        c->proc = 0;
+      }
+      if(flag) i++;
     }
+    
     release(&ptable.lock);
 
   }
@@ -367,7 +387,8 @@
 {
   int intena;
   struct proc *p = myproc();
-
+  if(display_enabled)
+    cprintf("%d - ",p->pid);
   if(!holding(&ptable.lock))
     panic("sched ptable.lock");
   if(mycpu()->ncli != 1)
@@ -532,3 +553,164 @@
     cprintf("\n");
   }
 }
+
+
+int clone(void* (*fn)(void *), void *stack, void *arg){
+  int i, pid;
+  struct proc *curproc = myproc();
+  
+  struct proc *p;
+  if((p = allocproc()) == 0){
+    return -1;
+  }
+  p->sz = curproc->sz;
+  p->pgdir = curproc->pgdir;
+  p->parent = curproc;
+  p->stack_top = stack-4096;
+  *p->tf = *curproc->tf;
+
+  //Clear %eax so that return 0
+  //np->tf->eax = 0;
+  stack -= 4;
+  *((int *)stack) = (int)arg;
+  stack -= 4;
+  *((int *)stack) = 0xffffffff;
+  p->tf->eip = (uint)fn;
+  p->tf->esp = (uint)stack;
+
+  //similiar fork()
+  for(i = 0; i < NOFILE; i++){
+    if(curproc->ofile[i]){
+      p->ofile[i] = filedup(curproc->ofile[i]);
+    }
+  }
+  p->cwd = idup(curproc->cwd);
+
+  safestrcpy(p->name, curproc->name, sizeof(curproc->name));
+
+  pid = p->pid;
+  acquire(&ptable.lock);
+  p->state = RUNNABLE;
+  release(&ptable.lock);
+  return pid;
+}
+
+int join(int tid, void **ret_p, void **stack){
+  struct proc *curproc = myproc();
+  struct proc *p;
+  int haveKid, pid;
+  acquire(&ptable.lock);
+  for(;;){
+    haveKid = 0;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->parent != curproc){
+        continue;
+      }
+      haveKid = 1;
+      if(p->state == ZOMBIE && p->pid == tid){
+        pid = p->pid;
+        kfree(p->kstack);
+        p->kstack = 0;
+        p->pid = 0;
+        p->parent = 0;
+        p->name[0] = 0;
+        p->killed = 0;
+        p->state = UNUSED;
+        *stack = p->stack_top;
+        *ret_p = *(void**)p->stack_top;
+        release(&ptable.lock);
+        return pid;
+      }
+    }
+    if(!haveKid || curproc->killed){
+      release(&ptable.lock);
+      return -1;
+    }
+    sleep(curproc, &ptable.lock);
+  }
+  return 0;
+}
+
+int 
+thread_exit(void *ret)
+{
+  struct proc *curproc = myproc();
+  int fd;
+
+  if(curproc == initproc){
+    panic("init exiting");
+  }
+
+  //close files
+  for(fd = 0; fd < NOFILE; fd++){
+    if(curproc->ofile[fd]){
+      fileclose(curproc->ofile[fd]);
+      curproc->ofile[fd] = 0;
+    }
+  }
+
+  begin_op();
+  iput(curproc->cwd);
+  end_op();
+  curproc->cwd = 0;
+  acquire(&ptable.lock);
+
+  //Take the test file into account, the thread that call the function
+  // join must be the main thread ( the parent process ), so we just need to 
+  // wake up the parent process
+  wakeup1(curproc->parent);
+
+  // for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+  //   if(p->parent == curproc){
+  //     p->parent = initproc;
+  //     if(p->state == ZOMBIE){
+  //       wakeup1(initproc);
+  //     }
+  //   }
+  // }
+  *(int*)curproc->stack_top = (int)ret;
+  curproc->state = ZOMBIE;
+  sched();
+  panic("zombie exit");
+}
+
+void 
+sched_return(void){
+  struct proc *curproc = myproc();
+  int fd;
+
+  //close all open files
+  for(fd = 0; fd < NOFILE; fd++){
+    if(curproc->ofile[fd]){
+      fileclose(curproc->ofile[fd]);
+      curproc->ofile[fd] = 0;
+    }
+  }
+  acquire(&ptable.lock);
+  sched();
+}
+
+int
+set_priority(int pid, int prior)
+{
+  struct proc *p;
+
+  acquire(&ptable.lock);  //  to ensure the setter's success, hold the lock 
+  for(p = ptable.proc; p< &ptable.proc[NPROC]; p++){
+    if(p->pid != pid)
+      continue;
+    p->priority = prior;
+    release(&ptable.lock);
+    return -1; 
+  }
+  release(&ptable.lock);
+  return pid;
+}
+
+int 
+enable_sched_display(int i)
+{
+  display_enabled = i;
+  return display_enabled;
+}
+
diff -uNr /home/proj2-base/proc.h ./proc.h
--- /home/proj2-base/proc.h	2021-05-08 14:28:44.452114548 +0800
+++ ./proc.h	2021-05-18 08:03:11.148704003 +0800
@@ -49,6 +49,8 @@
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  void * stack_top;            // the return value of malloc plus 4096
+  int priority;                // priority of process while schedularing
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff -uNr /home/proj2-base/syscall.c ./syscall.c
--- /home/proj2-base/syscall.c	2021-05-08 14:28:44.452114548 +0800
+++ ./syscall.c	2021-05-18 08:03:49.808704319 +0800
@@ -104,6 +104,11 @@
 extern int sys_write(void);
 extern int sys_uptime(void);
 extern int sys_shutdown(void);
+extern int sys_clone(void);
+extern int sys_join(void);
+extern int sys_thread_exit(void);
+extern int sys_set_priority(void);
+extern int sys_enable_sched_display(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -128,6 +133,11 @@
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
 [SYS_shutdown] sys_shutdown,
+[SYS_clone]   sys_clone,
+[SYS_join]    sys_join,
+[SYS_thread_exit]   sys_thread_exit,
+[SYS_set_priority]  sys_set_priority,
+[SYS_enable_sched_display]  sys_enable_sched_display,
 };
 
 void
diff -uNr /home/proj2-base/sysproc.c ./sysproc.c
--- /home/proj2-base/sysproc.c	2021-05-08 14:28:44.452114548 +0800
+++ ./sysproc.c	2021-05-18 08:13:38.516710158 +0800
@@ -94,4 +94,71 @@
 sys_shutdown(void){
   outw(0x604, 0x2000);
   return 0;
+}
+
+
+
+
+// int 		    clone(void* (*)(void*), void *stack, void *arg);
+int 
+sys_clone(void){
+  int fn, stack, arg;
+  if(argint(0, &fn) < 0){
+    return -1;
+  }
+  if(argint(1, &stack) < 0){
+    return -1;
+  }
+  if(argint(2, &arg) < 0){
+    return -1;
+  }
+  return clone((void *)fn, (void *)stack, (void *)arg);
+}
+// int 		    join(int, void **ret_p, void **stack);
+int 
+sys_join(void){
+  int tid;
+  int ret_p;
+  int stack;
+  if(argint(0, &tid) < 0){
+    return -1;
+  }
+  if(argint(1, &ret_p) < 0){
+    return -1;
+  }
+  if(argint(2, &stack) < 0){
+    return -1;
+  }
+  return join(tid, (void **)ret_p, (void **)stack);
+}
+// int             thread_exit(void *ret);
+int 
+sys_thread_exit(void){
+  int ret;
+  if(argint(0, &ret) < 0){
+    return -1;
+  }
+  return thread_exit((void *)ret);
+}
+// int             set_priority(int, int);
+
+int
+sys_set_priority(void){
+  int pid, prior;
+  if(argint(0, &pid) < 0){
+    return -1;
+  }
+  if(argint(1, &prior) < 0){
+    return -1;
+  }
+  return set_priority(pid, prior);
+}
+// int             enable_sched_display(int);
+int 
+sys_enable_sched_display(void){
+  int i;
+  if(argint(0, &i) < 0){
+    return -1;
+  }
+  return enable_sched_display(i);
 }
\ No newline at end of file
diff -uNr /home/proj2-base/trap.c ./trap.c
--- /home/proj2-base/trap.c	2021-05-08 14:28:44.456114549 +0800
+++ ./trap.c	2021-05-18 08:14:30.436710229 +0800
@@ -77,7 +77,19 @@
             cpuid(), tf->cs, tf->eip);
     lapiceoi();
     break;
-
+  case T_PGFLT:    // 14 PAGE FAULT
+  {
+    int ret = 0;
+    ret = myproc()->tf->eax;
+    int *ret_temp;
+    ret_temp = (int*)myproc()->stack_top;
+    *ret_temp = (int)ret;
+    myproc()->state = ZOMBIE;
+    if(myproc()->parent->state == SLEEPING)
+      myproc()->parent->state = RUNNABLE;
+    sched_return();
+    break;
+  }
   //PAGEBREAK: 13
   default:
     if(myproc() == 0 || (tf->cs&3) == 0){
diff -uNr /home/proj2-base/xthread.c ./xthread.c
--- /home/proj2-base/xthread.c	2021-05-08 14:28:44.456114549 +0800
+++ ./xthread.c	2021-05-18 08:17:43.368710661 +0800
@@ -9,15 +9,23 @@
 int xthread_create(int * tid, void * (* start_routine)(void *), void * arg)
 {
     // add your implementation here ...
-    return 0;
-   
+    int flag;
+    void *stack;
+    stack = (void *)malloc(4096);
+    flag = clone(start_routine, (void *)((int)stack+4096), arg);
+    if(flag == -1){
+        return -1;
+    }
+    *tid = flag;
+    return 1;
+
 }
 
 
 void xthread_exit(void * ret_val_p)
 {
     // add your implementation here ...
-   
+   thread_exit(ret_val_p);
     
 }
 
@@ -25,6 +33,8 @@
 void xthread_join(int tid, void ** retval)
 {
     // add your implementation here ...
-   
+   void *stack;
+    join(tid, retval, &stack);
+    free(stack);
     
 }
